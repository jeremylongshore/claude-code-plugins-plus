---
import PlaybookTemplate from '../../components/PlaybookTemplate.astro';

const meta = {
  title: "Cost Caps & Budget Management",
  description: "Hard budget controls for AI spending. Real-time spend tracking, automatic shutoffs, team quotas, and financial safeguards to prevent runaway costs.",
  category: "Cost",
  wordCount: 3200,
  slug: "02-cost-caps"
};
---

<PlaybookTemplate {...meta}>
  <div set:html={`<p>API costs can spiral quickly when running multi-agent workflows at scale. This playbook provides proven strategies for implementing cost controls, monitoring spend in real-time, and optimizing Claude API usage without sacrificing quality.</p>

<h2>Understanding API Costs</h2>

<h3>Anthropic Claude Pricing (January 2025)</h3>

<table>
<thead>
<tr>
<th>Model</th>
<th>Input (per 1M tokens)</th>
<th>Output (per 1M tokens)</th>
<th>Context Window</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Claude 3.5 Sonnet</strong></td>
<td>&#36;3.00</td>
<td>&#36;15.00</td>
<td>200K</td>
</tr>
<tr>
<td><strong>Claude 3.5 Haiku</strong></td>
<td>&#36;0.80</td>
<td>&#36;4.00</td>
<td>200K</td>
</tr>
<tr>
<td><strong>Claude 3 Opus</strong></td>
<td>&#36;15.00</td>
<td>&#36;75.00</td>
<td>200K</td>
</tr>
</tbody>
</table>

<p><strong>Reality Check</strong>: A single code review session can cost:</p>
<ul>
<li>Small file (500 tokens): &#36;0.0075 (Sonnet)</li>
<li>Large file (5,000 tokens): &#36;0.075 (Sonnet)</li>
<li>Full repository (50,000 tokens): &#36;0.75 (Sonnet)</li>
</ul>

<h3>Hidden Cost Drivers</h3>

<pre><code class="language-typescript">// ❌ This conversation costs &#36;4.50
const response = await claude.messages.create({
  model: &#039;claude-3-5-sonnet-20241022&#039;,
  max_tokens: 4096,
  messages: [{
    role: &#039;user&#039;,
    content: &#96;Review this entire codebase: &#36;{fs.readFileSync(&#039;monorepo.txt&#039;)}&#96; // 250K tokens
  }]
});

// Breakdown:
// - Input: 250K tokens × &#36;3/1M = &#36;0.75
// - Output: 4K tokens × &#36;15/1M = &#36;0.06
// - Total per call: &#36;0.81
//
// Multi-agent workflow (5 agents):
// - 5 agents × &#36;0.81 = &#36;4.05
// - Daily runs: 10
// - Monthly cost: &#36;4.05 × 10 × 30 = &#36;1,215</code></pre>

<hr>

<h2>Cost Tracking</h2>

<h3>1. Real-Time Token Counting</h3>

<pre><code class="language-typescript">import Anthropic from &#039;@anthropic-ai/sdk&#039;;

interface CostMetrics {
inputTokens: number;
outputTokens: number;
inputCost: number;
outputCost: number;
totalCost: number;
model: string;
}

class CostTracker {
private costs: CostMetrics[] = [];

// Pricing table (per 1M tokens)
private pricing = {
&#039;claude-3-5-sonnet-20241022&#039;: { input: 3.00, output: 15.00 },
&#039;claude-3-5-haiku-20241022&#039;: { input: 0.80, output: 4.00 },
&#039;claude-3-opus-20240229&#039;: { input: 15.00, output: 75.00 },
};

track(usage: Anthropic.Usage, model: string): CostMetrics {
const prices = this.pricing[model];

const metrics: CostMetrics = {
inputTokens: usage.input_tokens,
outputTokens: usage.output_tokens,
inputCost: (usage.input_tokens / 1_000_000) * prices.input,
outputCost: (usage.output_tokens / 1_000_000) * prices.output,
totalCost: 0,
model
};

metrics.totalCost = metrics.inputCost + metrics.outputCost;
this.costs.push(metrics);

return metrics;
}

getTotalCost(): number {
return this.costs.reduce((sum, c) =&gt; sum + c.totalCost, 0);
}

getCostByModel(model: string): number {
return this.costs
.filter(c =&gt; c.model === model)
.reduce((sum, c) =&gt; sum + c.totalCost, 0);
}

getAverageCostPerRequest(): number {
return this.getTotalCost() / this.costs.length;
}
}

// Usage
const tracker = new CostTracker();

const response = await claude.messages.create({
model: &#039;claude-3-5-sonnet-20241022&#039;,
messages: [...]
});

const cost = tracker.track(response.usage, response.model);
console.log(&#96;Request cost: &#36;&#36;{cost.totalCost.toFixed(4)}&#96;);
console.log(&#96;Total spent: &#36;&#36;{tracker.getTotalCost().toFixed(2)}&#96;);</code></pre>

<h3>2. Analytics Daemon Integration</h3>

<p>The <code>@claude-code-plugins/analytics-daemon</code> emits cost events:</p>

<pre><code class="language-typescript">// WebSocket event from analytics daemon
interface CostUpdateEvent {
  type: &#039;cost.update&#039;;
  timestamp: number;
  conversationId: string;
  model: &#039;claude-3-5-sonnet-20241022&#039;;
  inputCost: 0.0045;
  outputCost: 0.012;
  totalCost: 0.0165;
  currency: &#039;USD&#039;;
}

// Monitor costs in real-time
const ws = new WebSocket(&#039;ws://localhost:3456&#039;);
ws.onmessage = (event) =&gt; {
const data = JSON.parse(event.data);
if (data.type === &#039;cost.update&#039;) {
updateBudget(data.totalCost);
}
};</code></pre>

<h3>3. Daily Budget Dashboard</h3>

<p>Query costs via HTTP API:</p>

<pre><code class="language-bash"># Get session costs
curl http://localhost:3333/api/sessions | jq &#039;.sessions[] | {id, plugins, totalCost}&#039;

# Get status including total spend
curl http://localhost:3333/api/status | jq &#039;.watcher&#039;</code></pre>

<hr>

<h2>Budget Enforcement</h2>

<h3>Strategy 1: Hard Caps with Circuit Breakers</h3>

<pre><code class="language-typescript">class BudgetEnforcer {
  private spent = 0;
  private dailyBudget: number;
  private lastReset: Date;

constructor(dailyBudgetUSD: number) {
this.dailyBudget = dailyBudgetUSD;
this.lastReset = new Date();
}

async executeWithBudget&lt;T&gt;(
fn: () =&gt; Promise&lt;{ result: T; cost: number }&gt;
): Promise&lt;T&gt; {
// Reset budget if new day
if (this.isNewDay()) {
this.spent = 0;
this.lastReset = new Date();
}

// Check budget before execution
if (this.spent &gt;= this.dailyBudget) {
throw new Error(
&#96;Daily budget exceeded: &#36;&#36;{this.spent.toFixed(2)} / &#36;&#36;{this.dailyBudget}&#96;
);
}

const { result, cost } = await fn();

this.spent += cost;

// Warn at 80%
if (this.spent &gt;= this.dailyBudget * 0.8) {
console.warn(
&#96;⚠️ 80% of daily budget used: &#36;&#36;{this.spent.toFixed(2)} / &#36;&#36;{this.dailyBudget}&#96;
);
}

return result;
}

private isNewDay(): boolean {
const now = new Date();
return now.toDateString() !== this.lastReset.toDateString();
}

getRemainingBudget(): number {
return Math.max(0, this.dailyBudget - this.spent);
}

getSpendPercentage(): number {
return (this.spent / this.dailyBudget) * 100;
}
}

// Usage
const budget = new BudgetEnforcer(50.00); // &#36;50/day

try {
await budget.executeWithBudget(async () =&gt; {
const response = await claude.messages.create(...);
const cost = calculateCost(response.usage);
return { result: response, cost };
});
} catch (error) {
// Budget exceeded - halt operations
console.error(&#039;Budget exhausted for today&#039;);
}</code></pre>

<h3>Strategy 2: Tiered Budgets by Priority</h3>

<pre><code class="language-typescript">enum Priority {
  CRITICAL = &#039;critical&#039;,  // &#36;100/day
  HIGH = &#039;high&#039;,          // &#36;50/day
  MEDIUM = &#039;medium&#039;,      // &#36;20/day
  LOW = &#039;low&#039;             // &#36;5/day
}

class TieredBudget {
private budgets = new Map&lt;Priority, BudgetEnforcer&gt;([
[Priority.CRITICAL, new BudgetEnforcer(100)],
[Priority.HIGH, new BudgetEnforcer(50)],
[Priority.MEDIUM, new BudgetEnforcer(20)],
[Priority.LOW, new BudgetEnforcer(5)],
]);

async execute&lt;T&gt;(
priority: Priority,
fn: () =&gt; Promise&lt;{ result: T; cost: number }&gt;
): Promise&lt;T&gt; {
const budget = this.budgets.get(priority)!;
return await budget.executeWithBudget(fn);
}

getStatus() {
return Array.from(this.budgets.entries()).map(([priority, budget]) =&gt; ({
priority,
spent: budget.getSpendPercentage().toFixed(1) + &#039;%&#039;,
remaining: &#039;&#36;&#039; + budget.getRemainingBudget().toFixed(2)
}));
}
}

// Usage
const tiered = new TieredBudget();

// Critical: Production incident debugging
await tiered.execute(Priority.CRITICAL, async () =&gt; {
const result = await debugIncident();
return { result, cost: 0.50 };
});

// Low: Non-urgent code reviews
await tiered.execute(Priority.LOW, async () =&gt; {
const result = await reviewCode();
return { result, cost: 0.05 };
});</code></pre>

<h3>Strategy 3: Per-User Quotas</h3>

<pre><code class="language-typescript">class UserQuotaManager {
  private userBudgets = new Map&lt;string, number&gt;();
  private userSpent = new Map&lt;string, number&gt;();

constructor(private defaultQuota: number = 10) {}

setQuota(userId: string, quotaUSD: number) {
this.userBudgets.set(userId, quotaUSD);
}

async executeForUser&lt;T&gt;(
userId: string,
fn: () =&gt; Promise&lt;{ result: T; cost: number }&gt;
): Promise&lt;T&gt; {
const quota = this.userBudgets.get(userId) || this.defaultQuota;
const spent = this.userSpent.get(userId) || 0;

if (spent &gt;= quota) {
throw new Error(
&#96;User &#36;{userId} quota exceeded: &#36;&#36;{spent.toFixed(2)} / &#36;&#36;{quota}&#96;
);
}

const { result, cost } = await fn();
this.userSpent.set(userId, spent + cost);

return result;
}

getUserStatus(userId: string) {
const quota = this.userBudgets.get(userId) || this.defaultQuota;
const spent = this.userSpent.get(userId) || 0;

return {
userId,
quota: &#36;&#36;{quota},
spent: &#36;&#36;{spent.toFixed(2)},
remaining: &#36;&#36;{(quota - spent).toFixed(2)},
percentage: &#96;&#36;{((spent / quota) * 100).toFixed(1)}%&#96;
};
}
}</code></pre>

<hr>

<h2>Optimization Strategies</h2>

<h3>1. Model Selection by Task</h3>

<pre><code class="language-typescript">// Cost comparison for 10K token input + 1K token output

const models = {
sonnet: {
input: (10_000 / 1_000_000) * 3.00,   // &#36;0.03
output: (1_000 / 1_000_000) * 15.00,  // &#36;0.015
total: 0.045                           // &#36;0.045
},
haiku: {
input: (10_000 / 1_000_000) * 0.80,   // &#36;0.008
output: (1_000 / 1_000_000) * 4.00,   // &#36;0.004
total: 0.012                           // &#36;0.012 (73% cheaper!)
},
opus: {
input: (10_000 / 1_000_000) * 15.00,  // &#36;0.15
output: (1_000 / 1_000_000) * 75.00,  // &#36;0.075
total: 0.225                           // &#36;0.225 (5x more expensive)
}
};

// Smart model selection
function selectModel(task: AgentTask): string {
if (task.requiresReasoning) {
return &#039;claude-3-5-sonnet-20241022&#039;; // Best reasoning
} else if (task.isSimple) {
return &#039;claude-3-5-haiku-20241022&#039;;  // 73% cost savings
} else {
return &#039;claude-3-5-sonnet-20241022&#039;; // Default
}
}

// Real savings example:
// 1000 simple tasks/day × &#36;0.045 (Sonnet) = &#36;45/day
// 1000 simple tasks/day × &#36;0.012 (Haiku) = &#36;12/day
// Savings: &#36;33/day = &#36;990/month</code></pre>

<h3>2. Context Window Optimization</h3>

<pre><code class="language-typescript">// ❌ Expensive: Send entire codebase every time
async function reviewFile(file: string, codebase: string) {
  return await claude.messages.create({
    model: &#039;claude-3-5-sonnet-20241022&#039;,
    messages: [{
      role: &#039;user&#039;,
      content: &#96;Codebase context:\n&#36;{codebase}\n\nReview:\n&#36;{file}&#96; // 100K + 5K tokens
    }]
  });
}
// Cost per call: 100K tokens × &#36;3/1M = &#36;0.30

// ✅ Optimized: Send only relevant context
async function reviewFileOptimized(file: string, relatedFiles: string[]) {
const context = relatedFiles.join(&#039;\n&#039;); // 10K tokens
return await claude.messages.create({
model: &#039;claude-3-5-sonnet-20241022&#039;,
messages: [{
role: &#039;user&#039;,
content: &#96;Related files:\n&#36;{context}\n\nReview:\n&#36;{file}&#96; // 10K + 5K tokens
}]
});
}
// Cost per call: 15K tokens × &#36;3/1M = &#36;0.045 (85% cheaper!)</code></pre>

<h3>3. Caching Strategy</h3>

<pre><code class="language-typescript">class ResponseCache {
  private cache = new Map&lt;string, { response: any; cost: number; timestamp: number }&gt;();
  private ttl = 3600000; // 1 hour

async execute&lt;T&gt;(
cacheKey: string,
fn: () =&gt; Promise&lt;{ result: T; cost: number }&gt;
): Promise&lt;{ result: T; cost: number; cached: boolean }&gt; {
const cached = this.cache.get(cacheKey);

if (cached &amp;&amp; Date.now() - cached.timestamp &lt; this.ttl) {
console.log(&#96;Cache hit: &#36;&#36;{cached.cost.toFixed(4)} saved&#96;);
return { result: cached.response, cost: 0, cached: true };
}

const { result, cost } = await fn();

this.cache.set(cacheKey, {
response: result,
cost,
timestamp: Date.now()
});

return { result, cost, cached: false };
}

getCacheStats() {
const entries = Array.from(this.cache.values());
return {
entries: entries.length,
totalSavings: entries.reduce((sum, e) =&gt; sum + e.cost, 0),
hitRate: 0 // Track separately
};
}
}

// Usage
const cache = new ResponseCache();

const { result, cost, cached } = await cache.execute(
&#96;code-review-&#36;{fileHash}&#96;,
async () =&gt; {
const response = await claude.messages.create(...);
return { result: response, cost: calculateCost(response.usage) };
}
);

// Real impact:
// 100 requests/day, 30% cache hit rate
// Without cache: 100 × &#36;0.045 = &#36;4.50/day
// With cache: 70 × &#36;0.045 = &#36;3.15/day
// Savings: &#36;1.35/day = &#36;40.50/month</code></pre>

<h3>4. Batch Processing</h3>

<pre><code class="language-typescript">// ❌ Process files individually
async function reviewFiles(files: string[]) {
  for (const file of files) {
    await claude.messages.create({
      messages: [{ role: &#039;user&#039;, content: &#96;Review: &#36;{file}&#96; }]
    });
  }
}
// Cost: 10 files × &#36;0.045 = &#36;0.45

// ✅ Batch process
async function reviewFilesBatch(files: string[]) {
const batches = chunk(files, 10); // 10 files per batch

for (const batch of batches) {
await claude.messages.create({
messages: [{
role: &#039;user&#039;,
content: &#96;Review these files:\n&#36;{batch.map((f, i) =&gt; \&#96;&#36;{i+1}. &#36;{f}\&#96;).join(&#039;\n&#039;)}&#96;
}]
});
}
}
// Cost: 1 batch × &#36;0.05 = &#36;0.05 (90% cheaper!)</code></pre>

<hr>

<h2>Production Examples</h2>

<h3>Example 1: Plugin Marketplace Review</h3>

<pre><code class="language-typescript">// Scenario: Review 258 plugins for security issues
// Average plugin size: 5K tokens
// Total tokens: 258 × 5K = 1.29M tokens

const budget = new BudgetEnforcer(10.00); // &#36;10 budget
const cache = new ResponseCache();
const tracker = new CostTracker();

async function reviewPlugins() {
const plugins = await getPlugins(); // 258 plugins
const results = [];

for (const plugin of plugins) {
try {
await budget.executeWithBudget(async () =&gt; {
const { result, cost, cached } = await cache.execute(
&#96;security-review-&#36;{plugin.id}&#96;,
async () =&gt; {
const response = await claude.messages.create({
model: &#039;claude-3-5-haiku-20241022&#039;, // Use cheaper model
max_tokens: 500,
messages: [{
role: &#039;user&#039;,
content: Security review:\n&#36;{plugin.code}
}]
});

const metrics = tracker.track(response.usage, response.model);
return { result: response, cost: metrics.totalCost };
}
);

results.push({ plugin: plugin.name, review: result, cached });
return { result, cost };
});
} catch (error) {
console.error(&#96;Budget exceeded at plugin &#36;{plugin.name}&#96;);
break;
}
}

return results;
}

// Real metrics:
// - Cost without optimization: 258 × &#36;0.045 = &#36;11.61 (exceeds budget)
// - Cost with Haiku: 258 × &#36;0.012 = &#36;3.10 (73% savings)
// - Cost with 50% cache: 129 × &#36;0.012 = &#36;1.55 (87% savings)
// - Plugins reviewed: 258 (all)
// - Budget remaining: &#36;8.45</code></pre>

<h3>Example 2: Cost Attribution by Team</h3>

<pre><code class="language-typescript">interface Team {
  name: string;
  members: string[];
  monthlyBudget: number;
}

class TeamBudgetManager {
private teams = new Map&lt;string, Team&gt;();
private teamSpend = new Map&lt;string, number&gt;();

addTeam(team: Team) {
this.teams.set(team.name, team);
this.teamSpend.set(team.name, 0);
}

async executeForTeam&lt;T&gt;(
teamName: string,
userId: string,
fn: () =&gt; Promise&lt;{ result: T; cost: number }&gt;
): Promise&lt;T&gt; {
const team = this.teams.get(teamName);
if (!team) throw new Error(&#96;Unknown team: &#36;{teamName}&#96;);
if (!team.members.includes(userId)) {
throw new Error(&#96;User &#36;{userId} not in team &#36;{teamName}&#96;);
}

const spent = this.teamSpend.get(teamName) || 0;
if (spent &gt;= team.monthlyBudget) {
throw new Error(&#96;Team &#36;{teamName} budget exceeded&#96;);
}

const { result, cost } = await fn();
this.teamSpend.set(teamName, spent + cost);

return result;
}

getTeamReport(teamName: string) {
const team = this.teams.get(teamName)!;
const spent = this.teamSpend.get(teamName) || 0;

return {
team: teamName,
members: team.members.length,
budget: &#36;&#36;{team.monthlyBudget},
spent: &#36;&#36;{spent.toFixed(2)},
remaining: &#36;&#36;{(team.monthlyBudget - spent).toFixed(2)},
percentageUsed: &#96;&#36;{((spent / team.monthlyBudget) * 100).toFixed(1)}%&#96;,
daysRemaining: 30 - new Date().getDate(),
projectedOverage: spent / new Date().getDate() * 30 &gt; team.monthlyBudget
};
}
}

// Usage
const manager = new TeamBudgetManager();

manager.addTeam({
name: &#039;Engineering&#039;,
members: [&#039;alice@example.com&#039;, &#039;bob@example.com&#039;],
monthlyBudget: 500
});

manager.addTeam({
name: &#039;QA&#039;,
members: [&#039;charlie@example.com&#039;],
monthlyBudget: 100
});

// Engineering team member makes request
await manager.executeForTeam(&#039;Engineering&#039;, &#039;alice@example.com&#039;, async () =&gt; {
const result = await runTests();
return { result, cost: 2.50 };
});

console.log(manager.getTeamReport(&#039;Engineering&#039;));
// {
//   team: &#039;Engineering&#039;,
//   members: 2,
//   budget: &#039;&#36;500&#039;,
//   spent: &#039;&#36;2.50&#039;,
//   remaining: &#039;&#36;497.50&#039;,
//   percentageUsed: &#039;0.5%&#039;,
//   daysRemaining: 7,
//   projectedOverage: false
// }</code></pre>

<hr>

<h2>ROI Analysis</h2>

<h3>Cost vs. Value Metrics</h3>

<pre><code class="language-typescript">interface WorkflowMetrics {
  name: string;
  costPerRun: number;
  timesSaved: number;    // minutes
  errorsPrevented: number;
  manualCost: number;    // &#36; per hour equivalent
}

function calculateROI(metrics: WorkflowMetrics): number {
const timeSavingsValue = (metrics.timesSaved / 60) * metrics.manualCost;
const errorCostSavings = metrics.errorsPrevented * 100; // &#36;100 per error

const totalValue = timeSavingsValue + errorCostSavings;
const totalCost = metrics.costPerRun;

return ((totalValue - totalCost) / totalCost) * 100;
}

// Example: Automated Code Review
const codeReviewMetrics: WorkflowMetrics = {
name: &#039;Automated Code Review&#039;,
costPerRun: 0.50,           // Claude API cost
timesSaved: 30,              // 30 minutes saved
errorsPrevented: 3,          // 3 bugs caught
manualCost: 100              // &#36;100/hour developer time
};

const roi = calculateROI(codeReviewMetrics);
// timeSavingsValue: (30/60) × &#36;100 = &#36;50
// errorCostSavings: 3 × &#36;100 = &#36;300
// totalValue: &#36;350
// totalCost: &#36;0.50
// ROI: ((&#36;350 - &#36;0.50) / &#36;0.50) × 100 = 69,900%

console.log(&#96;ROI: &#36;{roi.toFixed(0)}%&#96;); // 69,900% ROI</code></pre>

<h3>Break-Even Analysis</h3>

<table>
<thead>
<tr>
<th>Workflow</th>
<th>API Cost/Run</th>
<th>Manual Cost/Run</th>
<th>Runs to Break Even</th>
</tr>
</thead>
<tbody>
<tr>
<td>Code Review</td>
<td>&#36;0.50</td>
<td>&#36;50</td>
<td>1</td>
</tr>
<tr>
<td>Test Generation</td>
<td>&#36;2.00</td>
<td>&#36;200</td>
<td>1</td>
</tr>
<tr>
<td>Documentation</td>
<td>&#36;1.00</td>
<td>&#36;80</td>
<td>1</td>
</tr>
<tr>
<td>Bug Triage</td>
<td>&#36;0.25</td>
<td>&#36;25</td>
<td>1</td>
</tr>
</tbody>
</table>

<p><strong>Key Insight</strong>: Even "expensive" AI workflows pay for themselves in the first run.</p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul>
<li><strong>Track every API call</strong></li>
</ul>
   <pre><code class="language-typescript">const tracker = new CostTracker();
   // Log costs to analytics daemon</code></pre>

<ul>
<li><strong>Set hard budget limits</strong></li>
</ul>
   <pre><code class="language-typescript">const budget = new BudgetEnforcer(50); // Never exceed &#36;50/day</code></pre>

<ul>
<li><strong>Use model selection</strong></li>
</ul>
   <pre><code class="language-typescript">const model = task.isComplex ? &#039;sonnet&#039; : &#039;haiku&#039;; // 73% savings</code></pre>

<ul>
<li><strong>Cache responses</strong></li>
</ul>
   <pre><code class="language-typescript">const cache = new ResponseCache();
   // 30% cache hit rate = 30% cost savings</code></pre>

<ul>
<li><strong>Monitor in real-time</strong></li>
</ul>
   <pre><code class="language-bash">ccp-analytics  # Watch costs live</code></pre>

<h3>DON'T ❌</h3>

<ul>
<li><strong>Don't use Opus for everything</strong></li>
</ul>
   <pre><code class="language-typescript">// ❌ 5x more expensive than Sonnet
   model: &#039;claude-3-opus-20240229&#039;</code></pre>

<ul>
<li><strong>Don't send full codebase every time</strong></li>
</ul>
   <pre><code class="language-typescript">// ❌ Wastes 90% of tokens
   content: fs.readFileSync(&#039;entire-repo.txt&#039;)</code></pre>

<ul>
<li><strong>Don't ignore token usage</strong></li>
</ul>
   <pre><code class="language-typescript">// ❌ No cost tracking
   await claude.messages.create({...});</code></pre>

<ul>
<li><strong>Don't run without budgets</strong></li>
</ul>
   <pre><code class="language-typescript">// ❌ Unlimited spending = surprise bills
   while (true) { await expensiveCall(); }</code></pre>

<hr>

<h2>Tools & Resources</h2>

<h3>Analytics Daemon</h3>
<p>Monitor costs in real-time:</p>
<pre><code class="language-bash">cd packages/analytics-daemon
pnpm start
# Cost events: ws://localhost:3456
# Cost API: http://localhost:3333/api/status</code></pre>

<h3>Anthropic Dashboard</h3>
<p>Official cost tracking: <a href="https://console.anthropic.com/">console.anthropic.com</a></p>

<h3>Plugins with Built-in Cost Optimization</h3>
<ul>
<li><code>performance-engineer</code> - Automatic model selection</li>
<li><code>cost-optimizer</code> - Budget tracking</li>
<li><code>cache-manager</code> - Response caching</li>
</ul>

<hr>

<h2>Summary</h2>

<p><strong>Key Takeaways</strong>:</p>

<ul>
<li><strong>Sonnet</strong>: &#36;3/1M input, &#36;15/1M output - Production standard</li>
<li><strong>Haiku</strong>: 73% cheaper - Use for simple tasks</li>
<li><strong>Context optimization</strong>: 85% cost savings</li>
<li><strong>Caching</strong>: 30% cost savings</li>
<li><strong>Budget enforcement</strong>: Prevents runaway costs</li>
</ul>

<p><strong>Cost Control Checklist</strong>:</p>
<ul>
<li>[ ] Implement CostTracker</li>
<li>[ ] Set daily budget limits</li>
<li>[ ] Use Haiku for simple tasks</li>
<li>[ ] Optimize context windows</li>
<li>[ ] Enable response caching</li>
<li>[ ] Monitor with analytics daemon</li>
<li>[ ] Calculate ROI for workflows</li>
<li>[ ] Set up team quotas</li>
</ul>

<hr>

<p><strong>Last Updated</strong>: 2025-12-24</p>
<p><strong>Author</strong>: Jeremy Longshore</p>
<p><strong>Related Playbooks</strong>: <a href="./01-multi-agent-rate-limits.md">Multi-Agent Rate Limits</a>, <a href="./08-performance-optimization.md">Performance Optimization</a></p>
`} />
</PlaybookTemplate>
