---
import PlaybookTemplate from '../../components/PlaybookTemplate.astro';

const meta = {
  title: "Incident Debugging Playbook",
  description: "SEV-1/2/3/4 incident response protocols. Log analysis, root cause investigation (5 Whys, Fishbone), postmortem templates, and on-call procedures.",
  category: "Operations",
  wordCount: 5000,
  slug: "05-incident-debugging"
};
---

<PlaybookTemplate {...meta}>
  <div set:html={`<p><strong>Production Playbook for DevOps and Plugin Maintainers</strong></p>

<p>Debugging production incidents in multi-agent Claude Code workflows requires systematic approaches to log analysis, root cause identification, and rapid remediation. This playbook provides battle-tested debugging techniques, incident response workflows, postmortem templates, and real-world examples of common failure modes.</p>

<h2>Incident Classification</h2>

<h3>Severity Levels</h3>

<table>
<thead>
<tr>
<th>Severity</th>
<th>Impact</th>
<th>Response Time</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SEV-1</strong></td>
<td>Production down</td>
<td>Immediate</td>
<td>All agents failing, API completely offline</td>
</tr>
<tr>
<td><strong>SEV-2</strong></td>
<td>Major degradation</td>
<td>15 minutes</td>
<td>50%+ error rate, critical features broken</td>
</tr>
<tr>
<td><strong>SEV-3</strong></td>
<td>Minor degradation</td>
<td>1 hour</td>
<td>Intermittent failures, single plugin broken</td>
</tr>
<tr>
<td><strong>SEV-4</strong></td>
<td>Cosmetic issues</td>
<td>24 hours</td>
<td>UI bugs, non-critical warnings</td>
</tr>
</tbody>
</table>

<h3>Common Incident Types</h3>

<pre><code class="language-typescript">enum IncidentType {
  API_FAILURE = &#039;api_failure&#039;,           // Claude API unreachable
  RATE_LIMIT = &#039;rate_limit&#039;,             // 429 errors from API
  TIMEOUT = &#039;timeout&#039;,                    // Agent/tool timeouts
  MEMORY_LEAK = &#039;memory_leak&#039;,           // Process memory exhaustion
  PLUGIN_CRASH = &#039;plugin_crash&#039;,         // Plugin process died
  DATA_CORRUPTION = &#039;data_corruption&#039;,   // Invalid data in DB/cache
  PERFORMANCE = &#039;performance&#039;,           // Slow response times
  AUTHENTICATION = &#039;authentication&#039;      // Auth failures
}

interface Incident {
id: string;
severity: &#039;SEV-1&#039; | &#039;SEV-2&#039; | &#039;SEV-3&#039; | &#039;SEV-4&#039;;
type: IncidentType;
startTime: number;
affectedUsers: number;
errorRate: number;
description: string;
}</code></pre>

<hr>

<h2>Initial Response Protocol</h2>

<h3>First 5 Minutes (SEV-1/SEV-2)</h3>

<p><strong>Step 1: Assess Impact</strong></p>
<pre><code class="language-bash"># Check current error rate
tail -n 1000 /var/log/claude-code.log | grep -c ERROR

# Check affected users
grep &quot;ERROR&quot; /var/log/claude-code.log | awk &#039;{print &#36;5}&#039; | sort -u | wc -l

# Check service health
curl http://localhost:3333/api/status</code></pre>

<p><strong>Step 2: Check Obvious Issues</strong></p>
<pre><code class="language-typescript">// Quick health check script
async function quickHealthCheck(): Promise&lt;{ healthy: boolean; issues: string[] }&gt; {
  const issues: string[] = [];

// 1. Check Claude API connectivity
try {
const response = await fetch(&#039;https://api.anthropic.com/v1/messages&#039;, {
method: &#039;POST&#039;,
headers: { &#039;x-api-key&#039;: process.env.ANTHROPIC_API_KEY },
body: JSON.stringify({ model: &#039;claude-3-5-haiku-20241022&#039;, messages: [{ role: &#039;user&#039;, content: &#039;test&#039; }], max_tokens: 10 })
});
if (!response.ok) issues.push(&#039;Claude API unreachable&#039;);
} catch (error) {
issues.push(&#039;Network connectivity issue&#039;);
}

// 2. Check disk space
const { stdout } = await execAsync(&quot;df -h / | tail -1 | awk &#039;{print &#36;5}&#039; | sed &#039;s/%//&#039;&quot;);
if (parseInt(stdout) &gt; 90) issues.push(&#039;Disk space critical&#039;);

// 3. Check memory
const memUsage = process.memoryUsage();
if (memUsage.heapUsed / memUsage.heapTotal &gt; 0.9) issues.push(&#039;Memory exhaustion&#039;);

return { healthy: issues.length === 0, issues };
}</code></pre>

<p><strong>Step 3: Stabilize (if possible)</strong></p>
<pre><code class="language-bash"># Restart failed services
systemctl restart claude-code-daemon
pm2 restart all

# Clear cache if corrupted
redis-cli FLUSHALL

# Rate limit protection
iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT</code></pre>

<h3>Communication Template</h3>

<pre><code class="language-markdown"># Incident Alert: [TITLE]

<strong>Severity</strong>: SEV-2
<strong>Status</strong>: Investigating
<strong>Started</strong>: 2025-12-24 14:35 UTC
<strong>Affected</strong>: ~1,200 users (15% of total)

&lt;h2&gt;Current Impact&lt;/h2&gt;
<ul>
<li>Agent execution failing with 429 errors</li>
<li>Error rate: 68% (normal: &lt;1%)</li>
<li>No data loss</li>
</ul>

&lt;h2&gt;Actions Taken&lt;/h2&gt;
<ul>
<li>‚úÖ Identified rate limit exhaustion (14:40)</li>
<li>‚úÖ Implemented emergency rate limiting (14:42)</li>
<li>üîÑ Monitoring recovery (14:45)</li>
</ul>

&lt;h2&gt;Next Update&lt;/h2&gt;
In 15 minutes or when resolved.</code></pre>

<hr>

<h2>Common Failure Modes</h2>

<h3>1. Rate Limit Exhaustion</h3>

<p><strong>Symptoms</strong>:</p>
<p>\&#96;\&#96;<code></p>
<p>Error 429: Rate limit exceeded</p>
<p>anthropic-ratelimit-requests-remaining: 0</p>
<p>anthropic-ratelimit-requests-reset: 2025-12-24T15:00:00Z</p>
<code>\&#96;</code>

<p><strong>Diagnosis</strong>:</p>
<pre><code class="language-typescript">async function diagnoseRateLimits(): Promise&lt;void&gt; {
  // Check recent API calls
  const recentCalls = await queryLogs(&#039;SELECT COUNT(*) FROM api_calls WHERE timestamp &gt; NOW() - INTERVAL 1 MINUTE&#039;);
  console.log(&#96;API calls in last minute: &#36;{recentCalls}&#96;);

// Check rate limit headers from last successful call
const lastHeaders = await getLastAPIHeaders();
console.log(&#039;Remaining requests:&#039;, lastHeaders[&#039;anthropic-ratelimit-requests-remaining&#039;]);
console.log(&#039;Reset time:&#039;, lastHeaders[&#039;anthropic-ratelimit-requests-reset&#039;]);
}</code></pre>

<p><strong>Fix</strong>:</p>
<pre><code class="language-typescript">// Implement token bucket rate limiter
class EmergencyRateLimiter {
  private tokens = 50; // Match API tier
  private lastRefill = Date.now();

async throttle(): Promise&lt;void&gt; {
this.refill();
while (this.tokens &lt; 1) {
await sleep(100);
this.refill();
}
this.tokens--;
}

private refill() {
const now = Date.now();
const elapsed = (now - this.lastRefill) / 1000;
const tokensToAdd = elapsed * (50 / 60); // 50 per minute
this.tokens = Math.min(50, this.tokens + tokensToAdd);
this.lastRefill = now;
}
}</code></pre>

<h3>2. Agent Timeout</h3>

<p><strong>Symptoms</strong>:</p>
<code>\&#96;</code>
<p>Error: Agent execution timed out after 300000ms</p>
<p>Task: code-review</p>
<p>Conversation: abc-123-def</p>
<code>\&#96;</code>

<p><strong>Diagnosis</strong>:</p>
<pre><code class="language-bash"># Check for hung processes
ps aux | grep claude | grep -v grep

# Check system load
uptime
# Output: load average: 12.5, 8.3, 5.2 (CPU overload!)

# Check for blocking I/O
iotop -o -d 5</code></pre>

<p><strong>Fix</strong>:</p>
<pre><code class="language-typescript">// Implement aggressive timeouts
class TimeoutManager {
  async executeWithTimeout&lt;T&gt;(
    fn: () =&gt; Promise&lt;T&gt;,
    timeoutMs: number
  ): Promise&lt;T&gt; {
    return Promise.race([
      fn(),
      new Promise&lt;never&gt;((_, reject) =&gt;
        setTimeout(() =&gt; reject(new Error(&#96;Timeout after &#36;{timeoutMs}ms&#96;)), timeoutMs)
      )
    ]);
  }
}

// Usage
const timeout = new TimeoutManager();
const result = await timeout.executeWithTimeout(
() =&gt; agent.execute(task),
30000 // 30 second hard limit
);</code></pre>

<h3>3. Memory Leak</h3>

<p><strong>Symptoms</strong>:</p>
<pre><code class="language-bash"># Memory usage climbing over time
free -m
#              total   used   free
# Mem:         16384  15892    492  # Critical!

# Process memory
ps aux --sort=-%mem | head -5
# claude-daemon: 8.2GB (!)</code></pre>

<p><strong>Diagnosis</strong>:</p>
<pre><code class="language-typescript">// Track memory usage over time
setInterval(() =&gt; {
  const usage = process.memoryUsage();
  console.log(JSON.stringify({
    timestamp: Date.now(),
    heapUsed: usage.heapUsed / 1024 / 1024, // MB
    heapTotal: usage.heapTotal / 1024 / 1024,
    external: usage.external / 1024 / 1024,
    rss: usage.rss / 1024 / 1024
  }));

// Trigger GC if usage &gt; 80%
if (usage.heapUsed / usage.heapTotal &gt; 0.8) {
global.gc(); // Requires --expose-gc flag
}
}, 60000); // Every minute</code></pre>

<p><strong>Common Causes</strong>:</p>
<pre><code class="language-typescript">// ‚ùå Leak: Global cache never cleared
const cache = new Map&lt;string, any&gt;();
function addToCache(key: string, value: any) {
  cache.set(key, value); // Grows forever!
}

// ‚úÖ Fix: LRU cache with size limit
import LRU from &#039;lru-cache&#039;;
const cache = new LRU&lt;string, any&gt;({ max: 1000 });</code></pre>

<h3>4. Plugin Crash Loop</h3>

<p><strong>Symptoms</strong>:</p>
<pre><code class="language-bash"># PM2 showing rapid restarts
pm2 status
# plugin-server | errored | 47 restarts in 2 minutes

# Logs show crash
tail -f /var/log/pm2/plugin-server-error.log
# Error: ECONNREFUSED 127.0.0.1:5432
# (PostgreSQL connection failed)</code></pre>

<p><strong>Diagnosis</strong>:</p>
<pre><code class="language-bash"># Check dependencies
docker ps | grep postgres
# (empty - PostgreSQL container not running!)

# Check network
netstat -tulpn | grep 5432
# (no listener on port 5432)</code></pre>

<p><strong>Fix</strong>:</p>
<pre><code class="language-bash"># Restart dependency
docker-compose up -d postgres

# Verify connectivity
psql -h localhost -U user -d database -c &quot;SELECT 1&quot;

# Restart plugin
pm2 restart plugin-server</code></pre>

<hr>

<h2>Debugging Techniques</h2>

<h3>1. Binary Search Debugging</h3>

<p><strong>Problem</strong>: Unknown change broke production</p>

<pre><code class="language-bash"># Use git bisect to find breaking commit
git bisect start
git bisect bad HEAD              # Current version is broken
git bisect good v1.2.0           # Last known good version

# Git will check out commits for testing
# Test each commit:
npm install &amp;&amp; npm run build &amp;&amp; npm test

# Mark results
git bisect good   # if tests pass
git bisect bad    # if tests fail

# Git will find the exact breaking commit</code></pre>

<h3>2. Correlation Analysis</h3>

<p><strong>Find patterns in failures</strong>:</p>
<pre><code class="language-typescript">interface FailureEvent {
  timestamp: number;
  errorType: string;
  userId?: string;
  pluginName?: string;
  duration: number;
}

function analyzeFailureCorrelations(failures: FailureEvent[]): void {
// Group by time windows
const byHour = groupBy(failures, f =&gt; Math.floor(f.timestamp / 3600000));

// Find spike times
const spikes = Object.entries(byHour)
.filter(([_, events]) =&gt; events.length &gt; 100)
.map(([hour, events]) =&gt; ({
hour: new Date(parseInt(hour) * 3600000),
count: events.length,
topError: mode(events.map(e =&gt; e.errorType))
}));

console.log(&#039;Failure spikes:&#039;, spikes);

// Find common attributes
const byPlugin = groupBy(failures, f =&gt; f.pluginName);
const suspiciousPlugin = Object.entries(byPlugin)
.sort((a, b) =&gt; b[1].length - a[1].length)[0];

console.log(&#96;Most failures from plugin: &#36;{suspiciousPlugin[0]} (&#36;{suspiciousPlugin[1].length} errors)&#96;);
}</code></pre>

<h3>3. Distributed Tracing</h3>

<p><strong>Track request across services</strong>:</p>
<pre><code class="language-typescript">import { trace, context, SpanStatusCode } from &#039;@opentelemetry/api&#039;;

const tracer = trace.getTracer(&#039;claude-code&#039;);

async function executeAgent(agentName: string, task: any): Promise&lt;any&gt; {
const span = tracer.startSpan(&#039;agent.execute&#039;, {
attributes: {
&#039;agent.name&#039;: agentName,
&#039;task.id&#039;: task.id
}
});

try {
// Execute agent logic
const result = await agent.run(task);

span.setStatus({ code: SpanStatusCode.OK });
span.setAttribute(&#039;result.success&#039;, true);

return result;
} catch (error) {
span.setStatus({
code: SpanStatusCode.ERROR,
message: error.message
});
span.recordException(error);
throw error;
} finally {
span.end();
}
}</code></pre>

<hr>

<h2>Log Analysis</h2>

<h3>Parsing Claude Code Logs</h3>

<p><strong>Log Format</strong>:</p>
<code>\&#96;</code>
<p>[2025-12-24T14:35:22.123Z] [ERROR] [agent:code-review] Rate limit exceeded</p>
<p>conversationId: abc-123-def</p>
<p>userId: user-456</p>
<p>errorCode: 429</p>
<p>retryAfter: 12</p>
<p>stack: Error: Rate limit exceeded</p>
<p>at callClaude (/app/src/api.ts:45:11)</p>
<code>\&#96;</code>

<p><strong>Analysis Script</strong>:</p>
<pre><code class="language-typescript">import { readFileSync } from &#039;fs&#039;;

interface LogEntry {
timestamp: Date;
level: &#039;ERROR&#039; | &#039;WARN&#039; | &#039;INFO&#039;;
component: string;
message: string;
metadata: Record&lt;string, any&gt;;
}

function parseLog(line: string): LogEntry | null {
const match = line.match(/\[(.<em>?)\] \[(.</em>?)\] \[(.<em>?)\] (.</em>)/);
if (!match) return null;

const [, timestamp, level, component, rest] = match;
const lines = rest.split(&#039;\n&#039;);
const message = lines[0];

// Parse metadata
const metadata: Record&lt;string, any&gt; = {};
for (const line of lines.slice(1)) {
const metaMatch = line.match(/^\s*(\w+): (.+)&#36;/);
if (metaMatch) {
const [, key, value] = metaMatch;
metadata[key] = value;
}
}

return {
timestamp: new Date(timestamp),
level: level as any,
component,
message,
metadata
};
}

function analyzeLogs(logPath: string): void {
const content = readFileSync(logPath, &#039;utf-8&#039;);
const logs = content.split(&#039;\n&#039;)
.map(parseLog)
.filter(Boolean) as LogEntry[];

// Error rate by component
const errorsByComponent = groupBy(
logs.filter(l =&gt; l.level === &#039;ERROR&#039;),
l =&gt; l.component
);

console.log(&#039;Errors by component:&#039;);
Object.entries(errorsByComponent)
.sort((a, b) =&gt; b[1].length - a[1].length)
.forEach(([component, errors]) =&gt; {
console.log(&#96;  &#36;{component}: &#36;{errors.length}&#96;);
});

// Recent errors (last 5 minutes)
const recentErrors = logs.filter(l =&gt;
l.level === &#039;ERROR&#039; &amp;&amp;
Date.now() - l.timestamp.getTime() &lt; 300000
);

console.log(&#96;\nRecent errors: &#36;{recentErrors.length}&#96;);
recentErrors.slice(0, 10).forEach(err =&gt; {
console.log(&#96;  &#36;{err.timestamp.toISOString()} - &#36;{err.message}&#96;);
});
}</code></pre>

<h3>Using Analytics Daemon</h3>

<pre><code class="language-typescript">// Query analytics daemon for incident patterns
const ws = new WebSocket(&#039;ws://localhost:3456&#039;);

ws.onmessage = (event) =&gt; {
const data = JSON.parse(event.data);

// Track rate limit warnings
if (data.type === &#039;rate_limit.warning&#039;) {
console.warn(&#96;‚ö†Ô∏è Rate limit approaching: &#36;{data.current}/&#36;{data.limit}&#96;);
}

// Track errors
if (data.type === &#039;llm.call&#039; &amp;&amp; data.error) {
console.error(&#96;‚ùå LLM call failed: &#36;{data.error}&#96;);
}
};

// Query historical data
const response = await fetch(&#039;http://localhost:3333/api/sessions&#039;);
const sessions = await response.json();
const failedSessions = sessions.filter(s =&gt; s.errorCount &gt; 0);

console.log(&#96;Failed sessions: &#36;{failedSessions.length}/&#36;{sessions.length}&#96;);</code></pre>

<hr>

<h2>Root Cause Analysis</h2>

<h3>The 5 Whys Method</h3>

<p><strong>Example: Agent Timeout Incident</strong></p>

<ul>
<li><strong>Why did the agent timeout?</strong></li>
</ul>
<p>‚Üí Because it took > 300 seconds to respond</p>

<ul>
<li><strong>Why did it take so long?</strong></li>
</ul>
<p>‚Üí Because the Claude API call was slow (280s)</p>

<ul>
<li><strong>Why was the API call slow?</strong></li>
</ul>
<p>‚Üí Because we sent a 50,000 token prompt</p>

<ul>
<li><strong>Why did we send such a large prompt?</strong></li>
</ul>
<p>‚Üí Because the code-reviewer agent included entire codebase in context</p>

<ul>
<li><strong>Why did it include the entire codebase?</strong></li>
</ul>
<p>‚Üí <strong>Root Cause</strong>: File globbing pattern </code><em>*/</em><code> matched all files including node_modules (500MB)</p>

<p><strong>Fix</strong>: Update file globbing to exclude node_modules</p>
<pre><code class="language-typescript">// Before: includes everything
const files = glob.sync(&#039;<em>*/</em>&#039;);

// After: exclude dependencies
const files = glob.sync(&#039;<em>*/</em>&#039;, {
ignore: [&#039;node_modules/<strong>&#039;, &#039;.git/</strong>&#039;, &#039;dist/**&#039;]
});</code></pre>

<h3>Fishbone Diagram (Ishikawa)</h3>

<pre><code class="language-typescript">interface RootCauseAnalysis {
  problem: string;
  categories: {
    people?: string[];
    process?: string[];
    technology?: string[];
    environment?: string[];
  };
  rootCause: string;
  fix: string;
}

const analysis: RootCauseAnalysis = {
problem: &#039;Agent timeout causing 68% error rate&#039;,
categories: {
people: [
&#039;Developer added file globbing without testing&#039;,
&#039;No code review caught the issue&#039;
],
process: [
&#039;No integration tests for large codebases&#039;,
&#039;No performance testing in CI/CD&#039;
],
technology: [
&#039;Glob pattern included node_modules (500MB)&#039;,
&#039;No size limit on prompts&#039;,
&#039;No timeout on file reading&#039;
],
environment: [
&#039;Production codebase larger than test repos&#039;,
&#039;No staging environment for testing&#039;
]
},
rootCause: &#039;Missing file size validation and glob pattern filtering&#039;,
fix: &#039;Add file exclusion patterns and max prompt size validation&#039;
};</code></pre>

<hr>

<h2>Recovery Procedures</h2>

<h3>Emergency Rollback</h3>

<pre><code class="language-bash"># Immediate rollback to last known good version
git log --oneline | head -5
# c534df4 (HEAD) feat: Add new feature (BROKEN)
# 3946b1f docs: Update README
# fc73caa (tag: v1.2.0) fix: Bug fix (LAST GOOD)

# Rollback
git reset --hard fc73caa
npm install
npm run build
pm2 restart all

# Deploy
./deploy.sh production

# Verify
curl http://api.example.com/health</code></pre>

<h3>Circuit Breaker Reset</h3>

<pre><code class="language-typescript">// Manually reset circuit breaker after fixing issue
class CircuitBreakerManager {
  private breakers = new Map&lt;string, CircuitBreaker&gt;();

reset(serviceName: string): void {
const breaker = this.breakers.get(serviceName);
if (breaker) {
breaker.state = &#039;closed&#039;;
breaker.failures = 0;
console.log(&#96;‚úì Reset circuit breaker for &#36;{serviceName}&#96;);
}
}

resetAll(): void {
for (const [service, breaker] of this.breakers) {
this.reset(service);
}
console.log(&#039;‚úì Reset all circuit breakers&#039;);
}
}</code></pre>

<h3>Data Recovery</h3>

<pre><code class="language-bash"># Recover from backup
BACKUP_DATE=&quot;2025-12-24-14:00&quot;

# Stop services
pm2 stop all

# Restore database
pg_restore -d database_prod backups/backup_&#36;{BACKUP_DATE}.sql

# Restore files
rsync -av backups/files_&#36;{BACKUP_DATE}/ /var/lib/claude-code/

# Restart
pm2 restart all

# Verify data integrity
psql -d database_prod -c &quot;SELECT COUNT(*) FROM conversations&quot;</code></pre>

<hr>

<h2>Postmortem Templates</h2>

<h3>Incident Postmortem</h3>

<pre><code class="language-markdown"># Postmortem: Agent Timeout Incident (2025-12-24)

<strong>Date</strong>: 2025-12-24
<strong>Duration</strong>: 14:35 - 15:15 UTC (40 minutes)
<strong>Severity</strong>: SEV-2
<strong>Impact</strong>: 1,200 users (15%), 68% error rate

&lt;h2&gt;Summary&lt;/h2&gt;
Code-reviewer agent began timing out due to excessive file inclusion in prompts, causing 68% error rate for 40 minutes.

&lt;h2&gt;Timeline (UTC)&lt;/h2&gt;
<ul>
<li><strong>14:35</strong> - First timeout alerts</li>
<li><strong>14:40</strong> - Error rate reaches 68%</li>
<li><strong>14:42</strong> - On-call engineer paged</li>
<li><strong>14:45</strong> - Root cause identified (file globbing)</li>
<li><strong>14:50</strong> - Fix deployed to staging</li>
<li><strong>14:55</strong> - Fix deployed to production</li>
<li><strong>15:00</strong> - Error rate drops to 5%</li>
<li><strong>15:15</strong> - Incident resolved, error rate &lt; 1%</li>
</ul>

&lt;h2&gt;Root Cause&lt;/h2&gt;
File globbing pattern </code><em>*/</em><code> included </code>node_modules/</code> directory (500MB), creating prompts exceeding Claude API&#039;s context limits and causing timeouts.

&lt;h2&gt;Contributing Factors&lt;/h2&gt;
<ul>
<li>No file size validation before prompt construction</li>
<li>No integration tests with large codebases</li>
<li>No staging environment for testing</li>
</ul>

&lt;h2&gt;What Went Well&lt;/h2&gt;
<ul>
<li>Fast root cause identification (10 minutes)</li>
<li>Effective rollback procedure</li>
<li>Clear communication to affected users</li>
</ul>

&lt;h2&gt;What Went Poorly&lt;/h2&gt;
<ul>
<li>No monitoring alerts before user reports</li>
<li>No prompt size limits prevented the issue</li>
<li>Fix took 20 minutes to deploy</li>
</ul>

&lt;h2&gt;Action Items&lt;/h2&gt;
<ul>
<li>[ ] <strong>P0</strong>: Add file size validation (Owner: @dev, Due: 2025-12-25)</li>
<li>[ ] <strong>P0</strong>: Implement max prompt size limit (Owner: @dev, Due: 2025-12-25)</li>
<li>[ ] <strong>P1</strong>: Add monitoring for agent timeouts (Owner: @ops, Due: 2025-12-27)</li>
<li>[ ] <strong>P1</strong>: Create staging environment (Owner: @ops, Due: 2025-12-30)</li>
<li>[ ] <strong>P2</strong>: Add integration tests with large repos (Owner: @qa, Due: 2026-01-05)</li>
</ul>

&lt;h2&gt;Lessons Learned&lt;/h2&gt;
<ul>
<li>File operations need size limits</li>
<li>Production testing with realistic data is critical</li>
<li>Monitoring must detect issues before users report them</code></pre></li>
</ul>

<hr>

<h2>Best Practices</h2>

<h3>DO ‚úÖ</h3>

<ul>
<li><strong>Log structured data</strong></li>
</ul>
   <pre><code class="language-typescript">// ‚úÖ Structured logging
   logger.error(&#039;Agent execution failed&#039;, {
     agentName: &#039;code-reviewer&#039;,
     conversationId: &#039;abc-123&#039;,
     errorCode: 429,
     duration: 1234
   });

// ‚ùå Unstructured
console.log(&#039;Error in code-reviewer agent&#039;);</code></pre>

<ul>
<li><strong>Set up alerts before incidents</strong></li>
</ul>
   <pre><code class="language-typescript">// Alert on error rate &gt; 5%
   if (errorRate &gt; 0.05) {
     pagerDuty.trigger({
       severity: &#039;critical&#039;,
       title: &#039;High error rate detected&#039;,
       details: &#96;Error rate: &#36;{(errorRate * 100).toFixed(1)}%&#96;
     });
   }</code></pre>

<ul>
<li><strong>Keep runbooks updated</strong></li>
</ul>
   <pre><code class="language-markdown"># Agent Timeout Runbook

1. Check logs: <code>tail -f /var/log/claude-code.log | grep TIMEOUT</code>
2. Identify pattern: Which agents are timing out?
3. Check system resources: <code>top, free -m</code>, </code>df -h\&#96;
4. If rate limits: Implement emergency throttling
5. If resource exhaustion: Restart services</code></pre>

<ul>
<li><strong>Test recovery procedures</strong></li>
</ul>
   <pre><code class="language-bash"># Monthly disaster recovery drill
   ./test-recovery.sh
   # 1. Trigger circuit breaker
   # 2. Verify monitoring alerts
   # 3. Execute rollback
   # 4. Verify service restoration</code></pre>

<h3>DON'T ‚ùå</h3>

<ul>
<li><strong>Don't skip postmortems</strong></li>
</ul>
   <pre><code class="language-typescript">// ‚ùå Mark as resolved without learning
   incident.status = &#039;resolved&#039;;

// ‚úÖ Document and learn
incident.status = &#039;resolved&#039;;
await createPostmortem(incident);
await scheduleReview(incident);</code></pre>

<ul>
<li><strong>Don't blame individuals</strong></li>
</ul>
   <pre><code class="language-markdown"># ‚ùå Blame-focused
   Root cause: Developer X wrote bad code

# ‚úÖ System-focused
Root cause: Missing code review process for file operations</code></pre>

<ul>
<li><strong>Don't ignore warning signs</strong></li>
</ul>
   <pre><code class="language-typescript">// ‚ùå Suppress warnings
   if (memoryUsage &gt; 0.8) {
     // TODO: Fix later
   }

// ‚úÖ Alert and track
if (memoryUsage &gt; 0.8) {
logger.warn(&#039;High memory usage&#039;, { usage: memoryUsage });
metrics.gauge(&#039;memory.usage&#039;, memoryUsage);
}</code></pre>

<hr>

<h2>Tools & Resources</h2>

<h3>Monitoring Tools</h3>

<p><strong>Analytics Daemon</strong> (from this marketplace):</p>
<pre><code class="language-bash">cd packages/analytics-daemon
pnpm start
# Real-time monitoring on http://localhost:3333</code></pre>

<p><strong>System Monitoring</strong>:</p>
<pre><code class="language-bash"># CPU, memory, disk
htop

# Network
iftop

# Disk I/O
iotop</code></pre>

<h3>Log Aggregation</h3>

<p><strong>Centralized logging</strong>:</p>
<pre><code class="language-bash"># Ship logs to central server
tail -f /var/log/claude-code.log | \
  nc logserver.example.com 514</code></pre>

<h3>External Tools</h3>

<ul>
<li><a href="https://www.datadoghq.com/">Datadog</a> - APM and monitoring</li>
<li><a href="https://sentry.io/">Sentry</a> - Error tracking</li>
<li><a href="https://www.pagerduty.com/">PagerDuty</a> - Incident management</li>
<li><a href="https://grafana.com/">Grafana</a> - Dashboards</li>
<li><a href="https://www.elastic.co/elk-stack">ELK Stack</a> - Log analysis</li>
</ul>

<hr>

<h2>Summary</h2>

<p><strong>Key Takeaways</strong>:</p>

<ul>
<li><strong>Classify incidents immediately</strong> - SEV-1/2 require immediate response</li>
<li><strong>Follow response protocol</strong> - Assess, stabilize, communicate</li>
<li><strong>Use systematic debugging</strong> - Binary search, correlation analysis, tracing</li>
<li><strong>Analyze logs effectively</strong> - Structured logging enables fast analysis</li>
<li><strong>Find root causes</strong> - 5 Whys and Fishbone diagrams prevent recurrence</li>
<li><strong>Document everything</strong> - Postmortems are learning opportunities</li>
<li><strong>Test recovery procedures</strong> - Practice makes perfect</li>
</ul>

<p><strong>Incident Response Checklist</strong>:</p>
<ul>
<li>[ ] Classify severity (SEV-1 through SEV-4)</li>
<li>[ ] Assess impact (error rate, affected users)</li>
<li>[ ] Check obvious issues (API, disk, memory)</li>
<li>[ ] Stabilize systems (restart, rate limit, rollback)</li>
<li>[ ] Communicate status to stakeholders</li>
<li>[ ] Identify root cause (5 Whys, logs, metrics)</li>
<li>[ ] Deploy fix and verify recovery</li>
<li>[ ] Write postmortem within 24 hours</li>
<li>[ ] Create action items with owners and dates</li>
<li>[ ] Schedule review meeting with team</li>
</ul>

<hr>

<p><strong>Last Updated</strong>: 2025-12-24</p>
<p><strong>Author</strong>: Jeremy Longshore</p>
<p><strong>Related Playbooks</strong>: <a href="./01-multi-agent-rate-limits.md">Multi-Agent Rate Limits</a>, <a href="./03-mcp-reliability.md">MCP Server Reliability</a></p>
`} />
</PlaybookTemplate>
